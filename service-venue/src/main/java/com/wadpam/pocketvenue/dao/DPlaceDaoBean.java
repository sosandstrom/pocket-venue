package com.wadpam.pocketvenue.dao;


import com.google.appengine.api.datastore.*;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.search.*;
import com.google.appengine.api.search.Index;
import com.wadpam.pocketvenue.domain.DPlace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Implementation of Business Methods related to entity DPlace.
 * This (empty) class is generated by mardao, but edited by developers.
 * It is not overwritten by the generator once it exists.
 *
 * Generated on 2012-09-02T11:34:32.312+0700.
 * @author mardao DAO generator (net.sf.mardao.plugin.ProcessDomainMojo)
 */
public class DPlaceDaoBean 
	extends GeneratedDPlaceDaoImpl
		implements DPlaceDao 
{
    static final Logger LOG = LoggerFactory.getLogger(DPlaceDao.class);

    static final String INDEX_NAME = "placeIndex";


    // Persist a place and update the index
    @Override
    public Long persistAndIndex(DPlace dPlace) {

        // Persist
        Long placeId = this.persist(dPlace);

        // Index the place
        Document document = Document.newBuilder()
                .setId(Long.toString(dPlace.getId()))
                .addField(Field.newBuilder().setName("name").setText(dPlace.getName()))  // TODO: Add more fields to index
                .build();

        try {
            // Add the document.
            getIndex().add(document);
        } catch (AddException e) {
            if (StatusCode.TRANSIENT_ERROR.equals(e.getOperationResult().getCode())) {
                LOG.error("Not possible to add document to index");
                // TODO: Error handling missing
            }
        }

        return placeId;
    }

    // Build index
    private Index getIndex() {
        IndexSpec indexSpec = IndexSpec.newBuilder()
                .setName(INDEX_NAME)
                .setConsistency(Consistency.PER_DOCUMENT)
                .build();
        return SearchServiceFactory.getSearchService().getIndex(indexSpec);
    }

    // Delete and update index
    public void deleteAndUpdateIndex(DPlace dPlace) {

        // Delete from data store
        delete(dPlace);

        // Remove from index
        getIndex().remove(Long.toString(dPlace.getId()));
    }


    // Search in the index for matching places
    @Override
    public Collection<DPlace> searchInIndexForPlaces(String text) {
        // TODO: support cursor

        // Build the query string
        String queryString = text;

        // Options
        QueryOptions options = QueryOptions.newBuilder()
                .setLimit(25)
                .build();

        // Build query
        com.google.appengine.api.search.Query query = com.google.appengine.api.search.Query.newBuilder()
                .setOptions(options)
                .build(queryString);

        try {
            // Query the index.
            Results<ScoredDocument> results = getIndex().search(query);

            Collection<Long> ids = new ArrayList<Long>();
            for (ScoredDocument document : results) {
                // Collect all the primary keys
                ids.add(Long.parseLong(document.getId()));
            }

            if (ids.size() != 0)
                // We got results, get the places from datastore
                return this.findByPrimaryKeys(ids).values();
            else
                // No results, return empty list
                return new ArrayList<DPlace>(0);

        } catch (SearchException e) {
            if (StatusCode.TRANSIENT_ERROR.equals(e.getOperationResult().getCode())) {
                LOG.error("Search index failed");
                // TODO: Error handling missing
            }
            throw new SearchException("Searching index failed");
        }
    }

    // Get all places
    @Override
    public String getPlaces(String cursor, int pageSize, Collection<DPlace> result) {
        LOG.debug(String.format("Get all place"));

        // Build a query, no filter
        Query query = new Query("DPlace");

        return getPlacesWithQuery(cursor, query, pageSize, result);
    }

    // Get all places for a parent
    @Override
    public String getPlacesForParent(String cursor, int pageSize, Long parentId, Collection<DPlace> result) {
        LOG.debug(String.format("Get all place for parent:%s", parentId));

        // Build a query
        Query query = new Query("DPlace");
        query.setFilter(new Query.FilterPredicate("parentId", Query.FilterOperator.EQUAL, parentId));

        return getPlacesWithQuery(cursor, query, pageSize, result);
    }

    // Get all places for a hierarchy
    @Override
    public String getPlacesForHierarchy(String cursor, int pageSize, String hierarchy, Collection<DPlace> result) {
        LOG.debug(String.format("Get all place for hierarchy:%s", hierarchy));

        // Build a query
        Query query = new Query("DPlace");
        query.setFilter(new Query.FilterPredicate("hierarchy", Query.FilterOperator.EQUAL, hierarchy));

        return getPlacesWithQuery(cursor, query, pageSize, result);
    }

    // Get all places for tags
    public String getPlacesForTags(String cursor, int pageSize, Long appTag1, Long appTag2, Collection<DPlace> result) {
        LOG.debug(String.format("Get all place for category tag id:%s and location tag id", appTag1, appTag2));

        // Build a query
        Query query = new Query("DPlace");
        if (null != appTag1 && null != appTag2)
            query.setFilter(Query.CompositeFilterOperator.and(
                    new Query.FilterPredicate("appTag1", Query.FilterOperator.EQUAL, appTag1),
                    new Query.FilterPredicate("appTag2", Query.FilterOperator.EQUAL, appTag2)));
        else if (null != appTag1)
            query.setFilter(new Query.FilterPredicate("appTag1", Query.FilterOperator.EQUAL, appTag1));
        else if (null != appTag2)
            query.setFilter(new Query.FilterPredicate("appTag2", Query.FilterOperator.EQUAL, appTag2));

        return getPlacesWithQuery(cursor, query, pageSize, result);
    }


    // Get places with query
    private String getPlacesWithQuery(String cursor, Query query, int pageSize ,Collection<DPlace> result) {
        LOG.debug(String.format("Get places with with cursor:%s page size:%d", cursor, pageSize));

        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

        PreparedQuery preparedQuery = datastore.prepare(query);

        // Set fetch options
        FetchOptions fetchOptions = FetchOptions.Builder.withLimit(pageSize);
        if (null != cursor)
            fetchOptions.startCursor(Cursor.fromWebSafeString(cursor));

        // Run the query
        QueryResultList<Entity> entities = preparedQuery.asQueryResultList(fetchOptions);

        // Build the DProduct domain object from the entities
        for (Entity entity : entities) {
            DPlace dPlace = new DPlace();

            LOG.debug(String.format("Entity key id: " + entity.getKey().getId()));
            dPlace.setId(entity.getKey().getId());
            dPlace.setParentId((Long)entity.getProperty("parentId"));
            dPlace.setHierarchy((String)entity.getProperty("hierarchy"));
            dPlace.setName((String)entity.getProperty("name"));
            result.add(dPlace);
        }

        // Get a new cursor
        String newCursor = entities.getCursor().toWebSafeString();

        return newCursor;
    }

    // Delete a tag id from all venues
    public void deleteTagId(Long tagId) {
        LOG.debug(String.format("Delete tag id:%s from all places", tagId));

        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

        // Build a query
        Query query = new Query("DPlace");
        query.setFilter(Query.CompositeFilterOperator.or(
                new Query.FilterPredicate("appTags1", Query.FilterOperator.EQUAL, tagId),
                new Query.FilterPredicate("appTags2", Query.FilterOperator.EQUAL, tagId)));

        PreparedQuery preparedQuery = datastore.prepare(query);

        // Iterates over the results and remove the tag
        Collection<Entity> updatedTags = new ArrayList<Entity>();
        for (Entity result : preparedQuery.asIterable()) {

            // Remove tag from tag group 1
            Collection<Long> existingTagIds = (Collection<Long>)result.getProperty("appTag1");
            if (null != existingTagIds)
                existingTagIds.remove(tagId);

            // Remove tag from tag group 2
            existingTagIds = (Collection<Long>)result.getProperty("appTag2");
            if (null != existingTagIds)
                existingTagIds.remove(tagId);

            // Update entity
            updatedTags.add(result);
        }
        // Update data store
        datastore.put(updatedTags);
    }

}
